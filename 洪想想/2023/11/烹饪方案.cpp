#include<bits/stdc++.h>
using namespace std;
long long dp[60][100005] = {0};
struct akak{//结构体，为了后面好排序
    long long a;
    long long b;
    long long c;
}ku[60];
long long t,n;
bool cmp(akak a,akak b){
    return a.c * b.b < b.c * a.b;
}

void slove(){
    sort(ku+1,ku+1+n,cmp);
    for(int i = 1; i <= n; i++){//遍历物体
        for(int j = 1; j <= t; j++){//遍历时间
            if(j >= ku[i].c){//只要时间够做
                /*if(dp[i - 1][j - ku[i].c] + ku[i].a - (j)*ku[i].b >=0)*/
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - ku[i].c] + ku[i].a - (j)*ku[i].b);
                /*else{
                    dp[i][j] =dp[i - 1][j];
                }*/
            }else{
                dp[i][j] = dp[i - 1][j];//取上一个位置的最优解
            }
        }
    }
    sort(dp[n],dp[n]+1+t);
    cout << dp[n][t] << endl;//输出总时间
}
/*100000 4
652 743 587 4926
6 5 3 4
4 5 3 6
*/
/*输出9167，肯定有问题，就算把那四个全加起来也没有9167*/
/*应该是因为时间的问题导致一碗菜被做了两次，but是因为数组开小了*/
/*100000 50
43870 35630 64332 29314 91810 30713 92083 34545 43527 8873 21291 94124 29550 3194 13615 95718 99109 37404 55083 46488 54658 52121 24121 75630 92015 31444 26858 83371 16195 32506 28091 82145 8476 19109 65026 11354 90026 27670 60557 59395 51931 80999 15095 49606 86010 50608 89208 64485 15134 6368
3 1 8 2 2 6 7 8 1 3 8 4 1 6 10 5 7 8 6 3 10 10 2 5 4 9 4 4 5 7 8 6 8 5 10 9 2 9 4 3 10 7 3 4 9 6 10 6 2 3
6309 173 7391 6248 4064 7879 1158 290 2884 7320 6407 3283 2389 433 290 8899 2240 8127 8931 4111 1159 2279 2104 3755 4672 2414 3974 8038 1926 7489 469 4875 2741 7641 6296 1737 2513 6449 6312 2901 6967 4875 4594 9131 4658 8092 3541 2247 6900 5777*/
//应该是0-1背包问题
/*答案485868，比答案少了10000左右*/
/*应该是累加的时候出了问题*/

/*卡在了95分，第14个样例点应该出0的，但是出了一个很大的数字*/
/*75766 5
81052 82080 95854 2368 92667
94284 82948 42838 56248 91578
12955 72088 72714 71219 1778*/
/*只能说他爆炸了，反向爆炸*/
int main(){
    cin >> t >> n;
    //存入值
    for(int i = 1; i <= n; i++){
        cin >> ku[i].a;
    }
    for(int i = 1; i <= n; i++){
        cin >> ku[i].b;
    }
    for(int i = 1; i <= n; i++){//时间
        cin >> ku[i].c;
    }
    slove();
    return 0;
}